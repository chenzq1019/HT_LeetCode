//
//  剑指offer32题.swift
//  HT_LeetCode
//
//  Created by 陈竹青 on 2021/1/8.
//

import Foundation

/**
 *  题目：输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。
 *
 *  例如：输入12， 从1到12这些数中包含1的数字有1、10、11、12，一个出现5次。
 *
 *   分析： 如果不考虑时间复杂度 ，最简单最直观的方法就是从1到n进行循环，然后每次对10取余，判断是否为1，如果大于10则，在取整在取余判断是否为1.
 **/

func testJianzhiOffer32() -> Void {
    var num  = numberOfBetween1AndN(n: 55)
    num = numberOfBetween1AndNMethodTwo(n: 21354, x: 1)
    print(num)
}

//方法一： 没有考虑时间复杂度的简单算法
fileprivate func numberOfBetween1AndN(n: Int) ->Int{
    if n <= 0 {
        print("请输入正确的数字")
        return 0
    }
    var totoal = 0
    for i in 1...n {
        var temp = i
        while temp > 0 {
            if temp % 10 == 1 {
                totoal += 1
            }
            temp = temp / 10
        }
    }
    return totoal
}

//方法二：
/**
 * 首先要知道以下的规律：
 
 从 1 至 10，在它们的个位数中，任意的 X 都出现了 1 次。

 从 1 至 100，在它们的十位数中，任意的 X 都出现了 10 次。

 从 1 至 1000，在它们的百位数中，任意的 X 都出现了 100 次。

 依此类推，从 1 至 10^ i ，在它们的左数第二位（右数第 i 位）中，任意的 X 都出现了 10^(i-1) 次。

 以21354为例，寻找1出现的次数：

 个位：从1至21350中包含了2135个10，因此1出现了2135次，21351，21352，21353，21354其中21351包含了一个1，故个位出现1的次数为：2135*10(1-1) + 1 = 2136次；

 公式：( 2135+1）* 10^(1-1) = 2136；

 十位：从1到21300中包含了213个100，因此1出现了213 * 10^(2-1) = 2130次，剩下的数字是21301到21354，它们的十位数字是5 > 1；因此它会包含10个1；故总数为2130 + 10 = 2140次；

 公式：（213 + 1）* 10^(2-1) = 2140次；

 百位：从1到21000中包含了21个1000，因此1出现了21 * 10^(3-1) = 2100次，剩下的数字是21001到21354，它们的百位数字是3 > 1；因此它会包含100个1；故总数为2100 + 100 = 2200次；

 公式：（21 + 1）* 10^(3-1) = 2200次；

 千位：从1到20000中包含了2个10000，因此1出现了2 * 10^(4-1) = 2000次，剩下的数字是20001到21354，它们的千位数字是1 = 1；情况稍微复杂些，354 + 1 = 355；故1的总数为2000 + 355 = 2355次；

 公式：2 * 10^(4-1) + 354 + 1 = 2355次；

 万位：万位是2 > 1，没有更高位；因此1出现的次数是1 * 10^(5-1) = 10000次；

 公式：（0 + 1）*10^(5-1) = 10000次；

 故总共为：2136+2140+2200+2355+10000=18831次；

 故总结：

 1、取第 i 位左边的数字（高位），乘以 10 ^(i−1) ，得到基础值 a 。
 2、取第 i 位数字，计算修正值：
 1、如果大于 X，则结果为 a+ 10 ^(i−1) 。
 2、如果小于 X，则结果为 a 。
 3、如果等 X，则取第 i 位右边（低位）数字，设为 b ，最后结果为 a+b+1 。
 */


fileprivate func numberOfBetween1AndNMethodTwo(n: Int, x : Int) ->Int{
    if n < 0 || x < 1 || x > 9 {
        return 0
    }
    var cur = 0
    var low = 0
    var temp = 0
    var high = n
    var i = 1
    var total = 0
    while high != 0 {
        //对10 取整
        high = n / Int(pow(10,Double(i)))
        //取余
        temp = n % Int(pow(10, Double(i)))
        //余数再取整
        cur =  temp / Int(pow(10, Double(i - 1)))
        low = temp % Int(pow(10, Double(i - 1)))
        if cur == x {
            total += high * Int(pow(10, Double(i - 1))) + low + 1
        }else if cur < x {
            total += high * Int(pow(10, Double(i - 1)))
        }else {
            total += (high + 1) * Int(pow(10, Double(i - 1)))
        }
        i += 1
    }
    return total
}
